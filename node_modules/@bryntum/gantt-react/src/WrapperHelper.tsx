/* eslint-disable @typescript-eslint/explicit-module-boundary-types,@typescript-eslint/no-unused-vars */
/**
 * React widget helper
 */
import React, { ReactElement } from 'react';
import ReactDOM, { flushSync } from 'react-dom';
import { DomHelper, StringHelper, Widget } from '@bryntum/gantt';

/**
 * Development warning. Showed when environment is set to 'development'
 * @param {String} clsName vue component instance
 * @param {String} msg console message
 */
function devWarning(clsName: string, msg: string): void {
    // @ts-ignore
    if (window.bryntum && window.bryntum.isTestEnv || process.env.NODE_ENV === 'development') {
        console.warn(
            `Bryntum${clsName}Component development warning!\n${msg}\n` +
            'Please check React integration guide: https://bryntum.com/products/gantt/docs/guide/Gantt/integration/react/guide'
        );
    }
}

function devWarningContainer(clsName: string, containerParam: string): void {
    devWarning(
        clsName,
        `Using "${containerParam}" parameter for configuration is not recommended.\n` +
        "Widget is placed automatically inside it's container element.\n" +
        `Solution: remove "${containerParam}" parameter from configuration.`
    );
}

function devWarningConfigProp(clsName: string, prop: string): void {
    devWarning(
        clsName,
        `Using "${prop}" parameter for configuration is not recommended.\n` +
        `Solution: Use separate parameter for each "${prop}" value to enable reactive updates of the API instance`
    );
}

/**
 * Creates bryntum component config from react component
 * @param {Object} reactInstance react component instance
 * @returns {Object} config object
 */
function createConfig(reactInstance: any): object {
    const { element, props, constructor } = reactInstance,
        { instanceClass, instanceName, isView } = constructor,
        filter = (arr: any[]) => arr.filter(prop => props[prop] !== undefined),
        configNames = filter(constructor.configNames || []),
        propertyConfigNames = filter(constructor.propertyConfigNames || []),
        propertyNames = filter(constructor.propertyNames || []),
        featureNames = filter(constructor.featureNames || []),
        bryntumConfig = {
            adopt                  : undefined,
            appendTo               : undefined,
            href                   : undefined,
            reactComponent         : reactInstance,
            listeners              : {},
            features               : {},
            hasFrameworkRenderer   : isView ? hasFrameworkRenderer : undefined,
            processCellContent     : isView ? processCellContent : undefined,
            processCellEditor      : isView ? processCellEditor : undefined,
            processEventContent    : isView ? processEventContent : undefined,
            processTaskItemContent : isView ? processTaskItemContent : undefined,
            processResourceHeader  : isView ? processResourceHeader : undefined
        } as any;

    // Data store configs support reactive behavior
    const isDataStoreConfig = (prop: any) => {
        if (reactInstance.dataStores) {
            const dataStoreNames = Object.values(reactInstance.dataStores);
            return dataStoreNames.includes(prop) || dataStoreNames.includes(`${prop}Data`);
        }
    };

    // Assign configs. Skip properties
    configNames
        .concat(propertyConfigNames)
        .concat(featureNames)
        .forEach(prop => {
            applyPropValue(bryntumConfig, prop, props[prop]);
            if (['features', 'config'].includes(prop) && !isDataStoreConfig(prop)) {
                devWarningConfigProp(instanceClass.$name, prop);
            }
        });

    // Prepare watch arrays
    reactInstance.configNames = configNames;
    reactInstance.propertyNames = configNames
        .concat(propertyNames)
        .concat(propertyConfigNames)
        .concat(featureNames);

    // Handle inline data for stores
    if (reactInstance.dataStores) {
        Object.values<string>(reactInstance.dataStores).forEach((dataName: string) => {
            if (props[dataName]) {
                bryntumConfig[dataName] = props[dataName];
            }
        });
    }

    // Cleanup unused instance arrays
    reactInstance.propertyConfigNames && delete reactInstance.propertyConfigNames;
    reactInstance.featureNames && delete reactInstance.featureNames;

    // If component has no container specified in config then use adopt to Wrapper's element
    const containerParam = ['adopt', 'appendTo', 'insertAfter', 'insertBefore'].find(
        prop => bryntumConfig[prop]
    );
    if (!containerParam) {
        if (instanceName === 'Button') {
            // Button should always be <a> or <button> inside owner element
            bryntumConfig.appendTo = element;
        }
        else {
            bryntumConfig.adopt = element;
        }
    }
    else {
        devWarningContainer(instanceClass.$name, containerParam);
    }

    return bryntumConfig;
}

/**
 * Applies property value to Bryntum config or instance.
 * @param {Object} configOrInstance target object
 * @param {String} prop property name
 * @param {Object} value value
 * @param {Boolean} isConfig config setting mode
 */
function applyPropValue(configOrInstance: any, prop: string, value: any, isConfig = true): void {
    // Assigning React wrapper component instance
    if (value?.current?.instance) {
        value = value.current.instance;
    }

    if (prop === 'features' && typeof value === 'object') {
        Object.keys(value).forEach(key =>
            applyPropValue(configOrInstance, `${key}Feature`, value[key], isConfig)
        );
    }
    else if (prop === 'config' && typeof value === 'object') {
        Object.keys(value).forEach(key =>
            applyPropValue(configOrInstance, key, value[key], isConfig)
        );
    }
    else if (prop === 'columns' && !isConfig) {
        configOrInstance.columns = value;
    }
    else if (prop.endsWith('Feature')) {
        const
            { features } = configOrInstance,
            featureName = prop.replace('Feature', '');
        if (isConfig) {
            features[featureName] = value;
        }
        else {
            const feature = features[featureName];
            if (feature) {
                feature.setConfig(value);
            }
        }
    }
    else {
        configOrInstance[prop] = value;
    }
}

/**
 * Creates bryntum Widget from react component
 * @param {*} component react component instance
 * @returns {*} widget object
 */
function createWidget(component: any): any {
    const { instanceClass, isView } = component.constructor,
        config = createConfig(component) as any,
        instance = instanceClass.$name === 'Widget' ? Widget.create(config) : new instanceClass(config);

    // Backwards compatibility for gridInstance, schedulerInstance etc.
    if (isView) {
        component[StringHelper.uncapitalize(instanceClass.$name) + 'Instance'] = instance;
    }

    if (isView) {
        // Backwards compatibility for gridInstance, schedulerInstance etc.
        component[StringHelper.uncapitalize(instanceClass.$name) + 'Instance'] = instance;

        const subscribeStores = (storeInstance: { [x: string]: any }, stores: {}) => {
            if (stores) {
                Object.keys(stores).forEach(storeName => {
                    const store = storeInstance[storeName];
                    if (store) {
                        // Default syncDataOnLoad to true if store is not configured with a readUrl (AjaxStore)
                        // and it doesn't belong to a project that has a loadUrl configured
                        if (store.syncDataOnLoad == null && !store.readUrl && (!store.crudManager || !store.crudManager.loadUrl)) {
                            store.syncDataOnLoad = true;
                        }

                        store.on('beforeRemove', (context: { records: any; removingAll: any }) => beforeRemoveRecords(component, context));
                    }
                });
            }
        };

        subscribeStores(component.projectStores ? instance.project : instance, component.dataStores);
    }

    // To be able to detect data changes later
    if (config['data']) {
        instance.lastDataset = config['data'].slice();
    }

    return instance;
}

/**
 * Calculates the portalId from passed ids
 * @param {String|Number} id
 * @param {String|Number} columnId
 * @returns {String} portalId as `portal-${id}-${columnId}`
 */
function getPortalId(id: string | number, columnId: string | number): string {
    return `portal-${id}-${columnId}`;
}

/**
 * Delete portal and its container
 * @param {*} component React Component, the wrapper itself
 * @param {String} portalId As returned from getPortalId function
 */
function deletePortal(component: any, portalId: string): void {
    const portal = component.state.portals.get(portalId);
    if (portal) {
        const portalContainer = portal.containerInfo;

        // remove portal from Map
        component.state.portals.delete(portalId);

        // cleanup portal container
        portalContainer.parentElement?.removeChild(portalContainer);
    }
}

/**
 * Release (now only delete) React portal hosted in this cell
 * @param {*} component React Component, the wrapper itself
 * @param {DOMElement} cellElement The grid cell to be freed of the React portal
 */
function releaseReactCell(component: any, cellElement: any): void {
    const { id, columnId, hasPortal } = cellElement._domData;

    if (hasPortal) {
        const portalId = getPortalId(id, columnId);
        deletePortal(component, portalId);
    }
}

/**
 * Calls releaseReactCell that implements the cleanup
 * @param {*} component React Component, the wrapper itself
 * @param {Object} context
 * @param {Core.data.Model[]} context.records Array of records that are going to be removed
 */
function beforeRemoveRecords(component: any, { records, removingAll }: { records: any[]; removingAll: boolean }): void {
    const { instance } = component;

    if (removingAll) {
        [...component.state.portals.keys()].forEach(portalId => deletePortal(component, portalId));
    }
    else {
        records.forEach(record => {
            // grid.getRowById is not defined in Calendar
            const row = instance.getRowById ? instance.getRowById(record.id) : undefined;
            if (row) {
                row.cells.forEach((cell: any) => {
                    releaseReactCell(component, cell);
                });
            }
        });
    }
}

/**
 * Increments generation - necessary to trigger React updates
 */
function updateGeneration(component: any, thisTick = false, callback = () => {}): void {
    const updateState = () => {
        component.setState((currentState : { generation: number; portals: Map<string, ReactElement> }) => {
            return {
                ...currentState,
                generation : currentState.generation + 1
            };
        }, callback);
    };
    if (thisTick) {
        // Update state in this tick
        updateState();
    }
    else {
        // React updates on next frame
        requestAnimationFrame(updateState);
    }
}

/**
 * Component about to be updated, from changing a prop using state.
 * React to it depending on what changed and prevent react from re-rendering our component.
 * @param {*} component react component instance
 * @param nextProps
 * @param nextState
 * @returns {Boolean}
 */
function shouldComponentUpdate(component: any, nextProps: Readonly<any>, nextState: Readonly<any>): boolean {
    const { props, instance, propertyNames } = component;

    propertyNames.forEach((prop: string) => {
        if (props[prop] !== nextProps[prop]) {
            // Check if property is not a config
            applyPropValue(instance, prop, nextProps[prop], false);
        }
    });

    // Reflect JSX cell changes
    return nextState?.generation !== component.state?.generation;
}

/**
 *
 * @param { Object } context
 * @param { * } context.cellContent Content to be rendered in cell (set by renderer)
 * @returns { Boolean } `true` if there is a React Renderer in this cell, `false` otherwise
 */
function hasFrameworkRenderer({ cellContent }: { cellContent: any }): boolean {
    // @ts-ignore
    return DomHelper.isReactElement(cellContent);
}

/**
 * Hook called by instance when rendering cells within
 * Row::renderCell(), creates portals for JSX supplied by renderers
 * @param {Object} context
 * @param {Object} context.rendererData Data passed from renderCell
 * @param {Object} context.cellElementData Data passed from renderCell
 */
function processCellContent(this: { reactComponent: any; isExporting: boolean }, { rendererData, cellElementData, rendererHtml }: { rendererData: any; cellElementData: any; rendererHtml: any }): void {
    // Collect variables
    const component = this.reactComponent;
    const { state, portalsCache, portalContainerClass } = component;
    const { cellElement, column, record } = rendererData;
    const portalId = getPortalId(record.id, column.id);
    const renderElement = cellElement.querySelector(column.editTargetSelector) || cellElement;

    // Do nothing if we have no place to render to
    if (!renderElement) {
        return;
    }
    if (
        rendererHtml &&
        // @ts-ignore
        DomHelper.isReactElement(rendererHtml) &&
        !record.meta.specialRow
    ) {
        // Move React portal container out of the way if necessary
        if (
            renderElement.portalContainer &&
            renderElement.portalContainer.dataset.portalId === portalId
        ) {
            portalsCache.appendChild(renderElement.portalContainer);
            renderElement.portalContainer = null;
        }

        // Try to get portal from the portals Map
        let portal = state.portals.get(portalId);

        // Handle measuring
        if (rendererData.isMeasuring) {
            if (portal) {
                // Remember the original parent of portal and the cell element width
                const portalContainer = portal.containerInfo;
                const parent = portalContainer.parentNode;
                cellElement.style.width = 'auto'; // element is re-used, need to reset width
                const cellElementWidth = cellElement.offsetWidth;

                // Append portal to the provided cell and get width
                cellElement.appendChild(portalContainer);
                const width = portalContainer.offsetWidth;

                // Move the portal back to its original container
                parent.appendChild(portalContainer);

                // Set width of the cell. It will be processed by Column code.
                cellElement.style.width = `${width + cellElementWidth}px`;
            }
            return;
        }

        // Check if record changed, delete portal and its container if yes
        if (portal?.generation !== record.generation) {
            deletePortal(component, portalId);
            portal = null;
        }

        // Cleanup renderElement - necessary for grouping feature
        const childPortalContainer = renderElement.querySelector(`.${portalContainerClass}`);
        if (childPortalContainer && childPortalContainer.dataset.portalId !== portalId) {
            portalsCache.appendChild(childPortalContainer);
        }
        if (renderElement.textContent && renderElement === cellElement) {
            renderElement.textContent = ''; // group title can be still here
        }

        if (portal) {
            // Move portal container back to the cell if we have one
            renderElement.appendChild(portal.containerInfo);
            renderElement.portalContainer = portal.containerInfo;
        }
        else {
            // Create new portal container
            const portalContainer = DomHelper.append(renderElement, {
                tag       : 'div',
                className : portalContainerClass,
                dataset   : { portalId } // for reference in tests
            });
            renderElement.portalContainer = portalContainer;

            // Create a new portal in the portal container
            portal = ReactDOM.createPortal(rendererHtml, portalContainer, portalId);

            // Add the new portal to Map
            state.portals.set(portalId, portal);

            // Trigger React redraw
            // Update cell synchronously when exporting
            updateGeneration(component, this.isExporting);
        }

        // Save data for use elsewhere
        cellElementData.hasPortal = true;
        portal.generation = record.generation;
    }
    else if (!rendererHtml && cellElementData.hasPortal) {
        cellElement.portalContainer.remove();
        cellElementData.hasPortal = false;
    }
}

/**
 * Hook called by engine when requesting a cell editor
 */
function processCellEditor({ editor, field }: { editor: any; field: string }): boolean | object | undefined {

    // @ts-ignore
    const component = this.reactComponent;

    // String etc. handled by feature, only care about fns returning React components here
    if (!component || typeof editor !== 'function') {
        return;
    }

    // Wrap React editor in an empty widget, to match expectations from CellEdit/Editor and make alignment
    // etc. work out of the box
    const wrapperWidget = new Widget({
        // For editor to be hooked up to field correctly,
        // @ts-ignore
        name             : field,
        // Prevent editor from swallowing mouse events
        allowMouseEvents : true,
        // Used by container, pass on to overridden setter
        assignValue(values: any, key: any, value: any) {
            // @ts-ignore
            this.setValue(value);
        }
    }) as any;

    // Ref for accessing the React editor later
    const widgetRef = React.createRef();
    wrapperWidget['reactRef'] = widgetRef;

    // `column.editor` is expected to be a function returning a React component (can be JSX).
    // Function is called with the ref from above, it has to be used as the ref for the editor to wire things up
    // and `this` which is the reference to the parent component (e.g. grid, scheduler, etc.)
    // See: https://github.com/bryntum/support/issues/5186
    // @ts-ignore
    const editorComponent = editor(widgetRef, this);

    // @ts-ignore
    if (!DomHelper.isReactElement(editorComponent)) {
        throw new Error('Expect a React element');
    }

    let editorValidityChecked = false;

    wrapperWidget.setValue = async(value:any) => {
        const widget: any = widgetRef.current;

        // It may happen that set is called before the widget is created
        if (widget) {
            if (!editorValidityChecked) {
                const
                    cellMethods = ['setValue', 'getValue', 'isValid', 'focus'],
                    misses      = cellMethods.filter(fn => !(fn in widget));

                if (misses.length > 0) {
                    throw new Error(
                        `Missing method(s) ${misses.join(', ')} in ${
                            widget.constructor.name
                        }. Cell editors must ${cellMethods.join(', ')}`
                    );
                }
                editorValidityChecked = true;
            }

            const context = wrapperWidget.owner['cellEditorContext'];
            await widget.setValue(value, context);
        }
        // The `widget` does not yet exist on first editor activation (creation)
        // so we save value here and set it later on the setState callback (see below)
        // https://github.com/bryntum/support/issues/6912
        else {
            wrapperWidget.firstValue = value;
        }
    };

    // Add getter/setter for value on the wrapper, relaying to getValue()/setValue() on the React editor
    Object.defineProperty(wrapperWidget, 'value', {
        enumerable   : true,
        // Fix for https://github.com/bryntum/support/issues/5041
        // Bryntum destroy logic tries to remove this property, so it must be possible
        configurable : true,

        get() {
            const widget: any = widgetRef.current;
            return widget?.getValue();
        }
    });

    // Add getter for isValid to the wrapper, mapping to isValid() on the React editor
    Object.defineProperty(wrapperWidget, 'isValid', {
        enumerable   : true,
        // Fix for https://github.com/bryntum/support/issues/5041
        // Bryntum destroy logic tries to remove this property so it must be possible
        configurable : true,

        get() {
            const widget: any = widgetRef.current;
            return widget?.isValid();
        }
    });

    // Override widgets focus handling, relaying it to focus() on the React editor
    wrapperWidget.focus = () => {
        const widget: any = widgetRef.current;
        if (!widget) {
            wrapperWidget.focusPending = true;
        }
        else {
            widget.focus?.();
        }
    };

    // Create a portal, making the React editor belong to the React tree although displayed in a Widget
    const portal = ReactDOM.createPortal(editorComponent, wrapperWidget.element);
    wrapperWidget['reactPortal'] = portal;

    const { state } = component;
    // Store portal in state to let React keep track of it (inserted into the Bryntum component)
    state.portals.set(`portal-${field}`, portal);
    updateGeneration(component, true,
        // setState callback that set the value of the widget if firstValue is defined
        // https://github.com/bryntum/support/issues/6912
        () => {
            if (wrapperWidget.firstValue !== undefined) {
                wrapperWidget.setValue(wrapperWidget.firstValue);
                delete wrapperWidget.firstValue;
            }
            if (wrapperWidget.focusPending) {
                wrapperWidget.focus();
                delete wrapperWidget.focusPending;
            }
        }
    );

    return { editor : wrapperWidget };
}

// Creates portal in the widget contentElement and triggers its rendering.
// Called from Widget.updateHtml
function processWidgetContent({ reactElement, widget, reactComponent, contentElement } :
{ reactElement: any; widget: any; reactComponent: any; contentElement: any }) : React.ReactPortal {
    const { state } = reactComponent,
        portal = ReactDOM.createPortal(reactElement, contentElement || widget.contentElement);

    state.portals.set(widget.id, portal);
    updateGeneration(reactComponent, true);

    return portal;
}

function processTaskItemContent({
    jsx,
    targetElement,
    reactComponent,
    domConfig
}: {
    jsx:ReactElement
    targetElement: HTMLElement
    reactComponent: React.Component
    domConfig : {[ key : string ] : any }
}) : void {
    if (!reactComponent || !jsx) {
        return;
    }
    const
        { state } = reactComponent,
        // @ts-ignore
        { portals } = state,
        cardElement = targetElement.closest('.b-taskboard-card') as any,
        portalId    = `task-item-${domConfig.reference}-${cardElement?.elementData.taskId}`,
        portal      = ReactDOM.createPortal(jsx, targetElement, portalId);

    portals.set(portalId, portal);

    updateGeneration(reactComponent);
}

function processEventContent(this: any, {
    jsx, // React element to render in portal
    action, // Rendering action
    targetElement, // DOM element to create portal in
    isRelease, // true if releasing element
    reactComponent, // the React wrapper component
    scrolling,
    domConfig
} : {
    jsx: ReactElement
    action: string
    targetElement: HTMLElement
    isRelease: boolean
    reactComponent: React.Component & {syncContent: (fn: () => unknown) => void}
    scrolling: boolean
    domConfig : any
}) : boolean {

    const { eventResize, eventDrag } = this.features;

    // Sanity check and do-nothing while user is resizing the event with D&D
    // 2nd and 3rd part fix https://github.com/bryntum/support/issues/6426
    // Fixes https://github.com/bryntum/support/issues/6664
    // `dragging.completed` test fixes https://github.com/bryntum/support/issues/7585
    // `&& !scrolling` test fixes https://github.com/bryntum/support/issues/8744
    // @ts-ignore
    if (!reactComponent || action === 'none' || (eventResize?.isResizing && !eventResize.dragging.completed && !scrolling)) {
        return false;
    }

    // Vertical nests renderData, while horizontal does not
    const domConfigData = this.isVertical ? domConfig?.elementData?.renderData : domConfig?.elementData;

    let wrap : any = targetElement,
        parent : any = null,
        // True signals the caller to finish further processing of this event
        returnValue = false;

    // When passed jsx, we are event content
    if (jsx) {
        // Milestone has a dedicated label element used for padding
        // We are looking here for `.b-sch-event-wrap`. This method is faster than `.closest(...)`
        if (domConfig?.dataset?.isMilestone) {
            wrap = targetElement.parentElement!.parentElement!.parentElement!;
            parent = targetElement.parentElement!;
        }
        else {
            wrap = targetElement.parentElement!.parentElement!;
            parent = targetElement;
        }
    }

    // When not passed jsx, we only care about continuing if we are the wrap, and not a ResourceTimeRange
    else if (!domConfigData?.isWrap || domConfigData.eventRecord.isResourceTimeRange) {
        return returnValue;
    }

    const
        // Vertical nests renderData, while horizontal does not
        wrapData = this.isVertical ? wrap.elementData.renderData : wrap.elementData,
        { assignmentRecord } = isRelease ? domConfigData : wrapData,
        // Store portals in state to let React keep track of them
        { state }   = reactComponent,
        // @ts-ignore
        { portals } = state,
        // Portals are used for cells etc too, use a unique id for the map
        portalId = `assignment-${assignmentRecord?.id}`;

    // Make this function available for testing. It should only be called on event drop.
    reactComponent.syncContent = reactComponent.syncContent || function(fn: () => unknown) {
        flushSync(fn);
    };

    if (isRelease) {
        if (portals.has(portalId)) {
            deletePortal(reactComponent, portalId);
            updateGeneration(reactComponent, true);
        }
    }
    else {
        // We also need to handle reusing own element containing a React element.
        // The portal for it has been released and needs to be restored
        jsx = jsx || (action === 'reuseOwnElement' && wrap.lastJSX);

        if (jsx) {
            parent = parent || wrap.querySelector('.b-sch-event-content');

            const updateContent = () => {
                // Clean-up the content element
                parent.innerHTML = '';
                const
                    jsxContainer = DomHelper.createElement({
                        className     : 'b-jsx-container b-event-text-wrap',
                        // As stated above, we are at the wrapper, but we should render the JSX inside the content element
                        parent,
                        // Signal DomSync to not remove React-controlled content
                        // https://github.com/bryntum/support/issues/7967
                        retainElement : true
                    }) as Element,
                    portal = ReactDOM.createPortal(jsx, jsxContainer);

                // Store the React element so that we can reuse it when reusing wrap element
                wrap.lastJSX = jsx;
                // Store portal in map in state, so that React can keep track of it
                portals.set(portalId, portal);
                updateGeneration(reactComponent, true);
            };

            if (scrolling || !eventDrag?.isDragging) {
                updateContent();
            }
            else {
                // Force React to run synchronously to prevent flickering (if not scrolling).
                // https://github.com/bryntum/support/issues/8464
                reactComponent.syncContent(updateContent);
            }
            returnValue = true;
        }
    }
    return returnValue;
}

/**
 * Called from DomSync callback to handle JSX
 * returned from ResourceHeader headerRenderer
 */
function processResourceHeader(
    { jsx, targetElement } :
    { jsx : ReactElement; targetElement : HTMLElement }) : void {

    if (!jsx) {
        return;
    }

    // @ts-ignore
    const { reactComponent } = this,
        { state } = reactComponent,
        { portals } = state,
        portalId = `resource-header-${targetElement.dataset.resourceId}`;

    // Delete portal if we already have one
    if (portals.has(portalId)) {
        portals.delete(portalId);

        // Update the generation (force React re-rendering) in this tick
        updateGeneration(reactComponent, true);
    }

    portals.set(portalId, ReactDOM.createPortal(jsx, targetElement));

    // Trigger the React portals re-rendering in the next animation frame
    updateGeneration(reactComponent);

}

export { createWidget, shouldComponentUpdate, processWidgetContent };
